-- Migration 012: SBT Staking (Proof of Human)
-- External SBT ownership verification and staking for rewards

-- ============================================================================
-- TABLE: sbt_ownership_cache
-- Purpose: Cache SBT ownership verification results for performance
-- ============================================================================
CREATE TABLE IF NOT EXISTS sbt_ownership_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Wallet and SBT info
  wallet_address TEXT NOT NULL,
  sbt_contract TEXT NOT NULL,
  token_id TEXT NOT NULL,
  chain TEXT NOT NULL,
  
  -- Verification status
  is_valid BOOLEAN NOT NULL DEFAULT true,
  verified_at TIMESTAMPTZ NOT NULL,
  last_check_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- On-chain data
  owner_address TEXT,
  metadata_uri TEXT,
  
  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Constraints
  UNIQUE(wallet_address, sbt_contract, token_id)
);

-- Indexes
CREATE INDEX idx_sbt_ownership_wallet ON sbt_ownership_cache(wallet_address);
CREATE INDEX idx_sbt_ownership_contract ON sbt_ownership_cache(sbt_contract);
CREATE INDEX idx_sbt_ownership_valid ON sbt_ownership_cache(is_valid);
CREATE INDEX idx_sbt_ownership_last_check ON sbt_ownership_cache(last_check_at);

-- ============================================================================
-- TABLE: staking_positions
-- Purpose: Track SBT staking positions (no actual token transfer)
-- ============================================================================
CREATE TABLE IF NOT EXISTS staking_positions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- User info
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  wallet_address TEXT NOT NULL,
  
  -- SBT reference
  sbt_token_id TEXT NOT NULL,
  sbt_contract TEXT NOT NULL,
  chain TEXT NOT NULL,
  
  -- Staking timeline
  staked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  unstaked_at TIMESTAMPTZ,
  
  -- Status
  status TEXT NOT NULL DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE', 'UNSTAKED')),
  
  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Constraints
  CHECK (unstaked_at IS NULL OR unstaked_at > staked_at)
);

-- Indexes
CREATE INDEX idx_staking_positions_user ON staking_positions(user_id);
CREATE INDEX idx_staking_positions_wallet ON staking_positions(wallet_address);
CREATE INDEX idx_staking_positions_status ON staking_positions(status);
CREATE INDEX idx_staking_positions_sbt ON staking_positions(sbt_contract, sbt_token_id);
CREATE INDEX idx_staking_positions_staked_at ON staking_positions(staked_at) WHERE status = 'ACTIVE';

-- ============================================================================
-- TABLE: staking_claims
-- Purpose: Track reward claims with $10 fee payment
-- ============================================================================
CREATE TABLE IF NOT EXISTS staking_claims (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- References
  position_id UUID NOT NULL REFERENCES staking_positions(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Claim amounts
  claim_amount_usdt NUMERIC(20, 2) NOT NULL CHECK (claim_amount_usdt > 0),
  claim_fee_paid NUMERIC(20, 2) NOT NULL DEFAULT 10.00 CHECK (claim_fee_paid >= 10.00),
  net_payout NUMERIC(20, 2) GENERATED ALWAYS AS (claim_amount_usdt - claim_fee_paid) STORED,
  
  -- Transaction tracking
  fee_payment_tx TEXT, -- User pays $10 fee first
  payout_tx TEXT, -- System sends net reward
  
  -- Status
  status TEXT NOT NULL DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'FEE_PAID', 'PAID_OUT', 'FAILED')),
  
  -- Timestamps
  claimed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  fee_paid_at TIMESTAMPTZ,
  paid_out_at TIMESTAMPTZ,
  
  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Idempotency
  idempotency_key TEXT,
  
  -- Constraints
  UNIQUE(idempotency_key)
);

-- Indexes
CREATE INDEX idx_staking_claims_position ON staking_claims(position_id);
CREATE INDEX idx_staking_claims_user ON staking_claims(user_id);
CREATE INDEX idx_staking_claims_status ON staking_claims(status);
CREATE INDEX idx_staking_claims_idempotency ON staking_claims(idempotency_key) WHERE idempotency_key IS NOT NULL;

-- ============================================================================
-- TABLE: staking_rewards_pool
-- Purpose: Track reward pool balance and source
-- ============================================================================
CREATE TABLE IF NOT EXISTS staking_rewards_pool (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Pool info
  pool_name TEXT NOT NULL DEFAULT 'SBT_STAKING',
  total_funded NUMERIC(20, 2) NOT NULL DEFAULT 0,
  total_claimed NUMERIC(20, 2) NOT NULL DEFAULT 0,
  available_balance NUMERIC(20, 2) GENERATED ALWAYS AS (total_funded - total_claimed) STORED,
  
  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Constraints
  CHECK (total_claimed <= total_funded),
  UNIQUE(pool_name)
);

-- Initialize default pool
INSERT INTO staking_rewards_pool (pool_name, total_funded) 
VALUES ('SBT_STAKING', 0)
ON CONFLICT (pool_name) DO NOTHING;

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Auto-update updated_at timestamp
CREATE TRIGGER update_sbt_ownership_cache_updated_at BEFORE UPDATE ON sbt_ownership_cache
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_staking_positions_updated_at BEFORE UPDATE ON staking_positions
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_staking_claims_updated_at BEFORE UPDATE ON staking_claims
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_staking_rewards_pool_updated_at BEFORE UPDATE ON staking_rewards_pool
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- FUNCTION: Calculate user's claimable rewards
-- ============================================================================
CREATE OR REPLACE FUNCTION calculate_sbt_staking_rewards(p_user_id UUID)
RETURNS NUMERIC AS $$
DECLARE
  v_active_position_id UUID;
  v_staked_at TIMESTAMPTZ;
  v_total_stakers INTEGER;
  v_pool_balance NUMERIC;
  v_already_claimed NUMERIC;
  v_time_staked_days INTEGER;
  v_reward_share NUMERIC;
BEGIN
  -- Get user's active staking position
  SELECT id, staked_at
  INTO v_active_position_id, v_staked_at
  FROM staking_positions
  WHERE user_id = p_user_id AND status = 'ACTIVE'
  ORDER BY staked_at DESC
  LIMIT 1;
  
  -- No active position
  IF v_active_position_id IS NULL THEN
    RETURN 0;
  END IF;
  
  -- Calculate days staked
  v_time_staked_days := EXTRACT(DAY FROM (NOW() - v_staked_at));
  
  -- Must stake at least 1 day
  IF v_time_staked_days < 1 THEN
    RETURN 0;
  END IF;
  
  -- Count total active stakers
  SELECT COUNT(*) INTO v_total_stakers
  FROM staking_positions
  WHERE status = 'ACTIVE';
  
  -- Get pool balance
  SELECT available_balance INTO v_pool_balance
  FROM staking_rewards_pool
  WHERE pool_name = 'SBT_STAKING';
  
  -- Get already claimed by this position
  SELECT COALESCE(SUM(claim_amount_usdt), 0)
  INTO v_already_claimed
  FROM staking_claims
  WHERE position_id = v_active_position_id 
    AND status IN ('PAID_OUT', 'FEE_PAID');
  
  -- Simple formula: pool / total_stakers, pro-rated by time
  -- (In production, use more sophisticated calculation)
  IF v_total_stakers > 0 AND v_pool_balance > 0 THEN
    v_reward_share := (v_pool_balance / v_total_stakers) * LEAST(v_time_staked_days / 30.0, 1.0);
    RETURN GREATEST(v_reward_share - v_already_claimed, 0);
  END IF;
  
  RETURN 0;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================================================

-- Enable RLS
ALTER TABLE sbt_ownership_cache ENABLE ROW LEVEL SECURITY;
ALTER TABLE staking_positions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staking_claims ENABLE ROW LEVEL SECURITY;
ALTER TABLE staking_rewards_pool ENABLE ROW LEVEL SECURITY;

-- SBT Ownership Cache: Users can read own, admins all
CREATE POLICY sbt_ownership_own_read ON sbt_ownership_cache
  FOR SELECT USING (wallet_address = (SELECT primary_wallet FROM profiles WHERE user_id = auth.uid()));

CREATE POLICY sbt_ownership_admin_all ON sbt_ownership_cache
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- Staking Positions: Users manage own
CREATE POLICY staking_positions_own_read ON staking_positions
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY staking_positions_own_insert ON staking_positions
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY staking_positions_own_update ON staking_positions
  FOR UPDATE USING (user_id = auth.uid());

CREATE POLICY staking_positions_admin_all ON staking_positions
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- Staking Claims: Users see own
CREATE POLICY staking_claims_own_read ON staking_claims
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY staking_claims_own_insert ON staking_claims
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY staking_claims_admin_all ON staking_claims
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- Rewards Pool: Public read (transparency)
CREATE POLICY rewards_pool_public_read ON staking_rewards_pool
  FOR SELECT USING (true);

CREATE POLICY rewards_pool_admin_write ON staking_rewards_pool
  FOR UPDATE USING (auth.jwt() ->> 'role' = 'service_role');

-- ============================================================================
-- COMMENTS FOR DOCUMENTATION
-- ============================================================================
COMMENT ON TABLE sbt_ownership_cache IS 'Cache for external SBT ownership verification results';
COMMENT ON TABLE staking_positions IS 'SBT staking positions - database-only, no token transfer';
COMMENT ON TABLE staking_claims IS 'Reward claim history with $10 flat fee per claim';
COMMENT ON TABLE staking_rewards_pool IS 'Reward pool funded by NFT_STAKING fee splits';

COMMENT ON COLUMN staking_claims.claim_fee_paid IS 'Flat $10 fee paid by user before reward payout';
COMMENT ON COLUMN staking_positions.status IS 'ACTIVE = currently staked, UNSTAKED = withdrawn (no cooldown)';
COMMENT ON FUNCTION calculate_sbt_staking_rewards IS 'Calculate claimable rewards for a user based on pool share and time staked';
